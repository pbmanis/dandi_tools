"""Display data from an NWB file generated by acq4_to_NWB
    Handles opto mapping as stored by acq4_to_NWB.py
"""
import argparse
from dataclasses import dataclass
from pathlib import Path
from typing import Union

import matplotlib.pyplot as mpl
import matplotlib.patches as mpatches
from matplotlib.collections import PatchCollection
import numpy as np
from pynwb import NWBHDF5IO

class ReadNWB():
    def __init__(self, filename:Union[str, Path, None]=None):
        if filename is None:
            return
        else:
            self.readfile(f=filename)

    def readfile(self, f: Union[Path, str, None]=None):
        """_summary_

        Params
        ------
            f (Union[Path, str, None], optional): File path. Defaults to None.
        
        Returns
        -------
        Nothing
        """        
        self.filename = f
        io = NWBHDF5IO(Path(f), mode="r")
        nwbfile = io.read()
        self.nwbfile = nwbfile
        di = nwbfile.get_intracellular_recordings()
        root_table = nwbfile.get_icephys_meta_parent_table()
        # print("Root table : ", root_table.neurodata_type)
        if root_table.has_foreign_columns():
            print("Has Foreign Columns:", root_table.has_foreign_columns())
            print("Foreign Columns:", root_table.get_foreign_columns())

        linked_tables = root_table.get_linked_tables()
        # Print the links
        for i, link in enumerate(linked_tables):
            print("%s (%s, %s) ----> %s" % ("    " * i,
                                            link.source_table.name,
                                            link.source_column.name,
                                            link.target_table.name))

        acquisition_names = nwbfile.acquisition.keys()
        doneprots = []
        for acq in acquisition_names:
            protocol = acq.split(':')[0]
            if protocol in doneprots: # the protocol name may appear multiple times
                continue
            recmode = nwbfile.acquisition[protocol+':Ics1'].comments
            if recmode in ['CC', 'IC']:  # get command and response data .. 
                self.command = nwbfile.acquisition[protocol+':Ics1'].data[:]
                self.response = nwbfile.acquisition[protocol+':Vcs1'].data[:]
                try:
                    self.opto = nwbfile.acquisition[protocol+':ChR2 Stimulation 1']
                except:
                    self.opto = None
            elif recmode == 'VC':
                self.response = nwbfile.acquisition[protocol+':Ics1'].data[:]
                self.command = nwbfile.acquisition[protocol+':Vcs1'].data[:]
                try:
                    self.opto = nwbfile.acquisition[protocol+':ChR2 Stimulation 1']
                except:
                    self.opto = None
            if self.opto is not None:
                self.optotimebase = np.linspace(0., self.opto.data.shape[0]/self.opto.rate, self.opto.data.shape[0])
            self.sample_rate = nwbfile.acquisition[protocol+':Vcs1'].rate  # data sample rate in Hz
            self.protocol = nwbfile.protocol
            self.time = np.linspace(0., self.response.shape[0]/self.sample_rate, self.response.shape[0])
            doneprots.append(protocol)
            self.plot_traces(recmode, protocol)


    def onpick(self, event):

        self.trace_plot[0].set_ydata(self.response[:, event.ind])
        self.ELabel.set_text(f"Trace {event.ind[0]:d}")
        self.fig.canvas.draw()
        self.fig.canvas.flush_events()

    def plot_traces(self, recmode:str, protocol:str):
        """Minimal plotter to show the data in an nwb file generated by acq4_to_NWB.py
        """

        fig, axs = mpl.subplot_mosaic([['A', 'D'], ['A', 'D'], ["A", "D"],["A", "D"], ['B', 'E'], ['C', 'F']],
                              constrained_layout=True, figsize=(8, 10))
        self.fig = fig
        self.axs = axs
        for ax in ["A", "B", "C", "E", "F"]:
            axs[ax].spines['right'].set_visible(False)
            axs[ax].spines['top'].set_visible(False)
        fig.suptitle(f"{str(self.filename):s}  {protocol:s}", fontsize=8, fontweight='demibold')
        if protocol.startswith("CCIV") or protocol.startswith("Ic"):
            delta_I = 0.075
        elif protocol.startswith("Vc") or protocol.startswith("Map"):
            delta_I = 100e-12
        else:
            raise ValueError(f"Protocol starting with : {protocol:s} not handled.")
        for i in range(self.response.shape[1]):
            axs['A'].plot(self.time, self.response[:,i]+i*delta_I, linewidth=0.33)
            axs['B'].plot(self.time, self.command[:,i], linewidth=0.33)

            if self.opto is not None:
                axs['C'].plot(self.optotimebase, self.opto.data[:, i])
        axs['F'].plot(self.time, np.mean(self.response, axis=1), linewidth=0.5)
        self.trace_plot = axs['E'].plot(self.time, self.response[:,0], 'g-', linewidth=0.5)
        self.ELabel = self.axs["E"].text(0.05, 0.95, f"Trace: {0:d}",
            ha = "left", va = "top",
            transform = self.axs["E"].transAxes)
        axs['A'].set_xlabel("T (s)")
        axs['F'].set_xlabel("T (s)")
        if recmode.lower() in ["cc", "ic"]:
            axs["A"].set_ylabel("V (V)")
            axs["B"].set_ylabel("I (A)")
            axs['F'].set_ylabel("V (V)")
        elif recmode.lower() in ['vc']:
            axs["A"].set_ylabel("I (A)")
            axs["B"].set_ylabel("V (V)")
            axs["F"].set_ylabel("mean I (A)")
        if self.opto is not None:
            axs["C"].set_xlabel("T (s)")
            axs["C"].set_ylabel("Intensity (AU)")

        # draw a map of the points by current
        if self.opto is not None:
            opos = np.array(self.opto.control) # .reshape(len(self.opto.control), 2)
            osize = float(self.opto.comments)*1e3  # bring to match units
            patches = []
            # create a circle to show the position of each stimulus
            for isp in range(opos.shape[0]):
                circle = mpatches.Circle((opos[isp,0]/1e3, opos[isp,1]/1e3), 
                radius=osize/2.0, color = 'blue', ec="none")
                patches.append(circle)
            collection = PatchCollection(patches, cmap=mpl.cm.cool, alpha=0.6)
            istim = int(0.5*self.sample_rate)
            onems = int(0.001*self.sample_rate) # self.EPC.sample_interval)
            twentyms = 20*onems
            colors =  np.sum(self.response[istim:istim+twentyms, :], axis=0) - np.mean(self.response[istim-twentyms:istim,:], axis=0) #, np.linspace(0, 1, len(patches))
            colors = colors/np.min(colors)
            collection.set_array(colors)
            collection.set_picker(True)
            axs["D"].add_collection(collection)
            axs["D"].set_facecolor("white")
            axs["D"].set_aspect("equal")
            axs["D"].scatter(np.mean(opos[:,0])/1e3, np.mean(opos[:,1]/1e3), s=0.1, marker='o')            
            fig.canvas.mpl_connect('pick_event', self.onpick)

        mpl.show()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Display an NWB file")
    parser.add_argument(dest="inputfile", type=str, help="input filenbame")
    args = parser.parse_args()
    
    R = ReadNWB(args.inputfile)
    # R.plot_traces()
