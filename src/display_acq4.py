"""Display data from an NWB file generated by acq4_to_NWB
    Handles opto mapping as stored by acq4_to_NWB.py
"""
import argparse
from dataclasses import dataclass
from pathlib import Path
from typing import Union

import matplotlib.patches as mpatches
import matplotlib.pyplot as mpl
import numpy as np
from ephys.datareaders import acq4_reader
from ephys.mapanalysistools import compute_scores
from matplotlib.collections import PatchCollection


class ReadAcq4:
    def __init__(self, filename: Union[str, Path, None] = None):
        if filename is None:
            return
        else:
            self.readfile(f=filename)


    def readfile(self, f: Union[Path, str, None] = None):
        """_summary_

        Params
        ------
            f (Union[Path, str, None], optional): File path. Defaults to None.

        Returns
        -------
        Nothing
        """
        self.filename = f
        self.trace_counter = 0
        self.AR = acq4_reader.acq4_reader(f)
        self.AR.getData()
        if self.AR.tstart > 0.0:
            # end trace at start of the pulse
            self.maxindex = int(self.AR.tstart*self.AR.sample_rate[0])

        self.idata = self.AR.traces.view(np.ndarray).T
        self.command = self.AR.cmd_wave.view(np.ndarray).T
        self.timebase = self.AR.time_base.T
        self.AR.getLaserBlueCommand()
        self.laser_command = self.AR.LaserBlue_pCell.view(np.ndarray).T
        self.laser_timebase = self.AR.LaserBlue_time_base.view(np.ndarray).T
        self.AR.getScannerPositions()
        self.plot_traces(self.AR.mode, Path(self.AR.protocol).name)

    def onpick(self, event):

        self.trace_counter += 1
        zero_position = 100e-12*(self.trace_counter-1)
        lp = self.axs["E"].plot(self.timebase[:self.maxindex],
            self.idata[:self.maxindex, event.ind]+zero_position, linewidth=0.5)
        color = lp[0].get_color()  # get color of last trace
        self.axs["E"].text(x=0., y=zero_position,
            s=f"Spot {event.ind[0]:d}", color=color,
            fontdict = {"fontsize": 8, "fontweight": "normal",
            "va": "bottom", "ha": "left"})
        self.ELabel.set_text(f"Trace {event.ind[0]:d}")
        lpos = [self.AR.scanner_positions[event.ind, 0] / 1e3,
                self.AR.scanner_positions[event.ind, 1] / 1e3,]

        self.axs["D"].text(x=lpos[0], y = lpos[1], 
            s=f"{self.trace_counter:d}", 
            fontdict = {"fontsize": 8, "fontweight": "bold",
                "va": "center", "ha": "center"})
        self.fig.canvas.draw()
        self.fig.canvas.flush_events()

    def plot_traces(self, recmode: str, protocol: str):
        """Minimal plotter to show the data in an nwb file generated by acq4_to_NWB.py"""

        fig, axs = mpl.subplot_mosaic(
            [["A", "D"], ["A", "D"], ["A", "D"], ["A", "D"], ["B", "E"], ["C", "F"]],
            constrained_layout=True,
            figsize=(8, 10),
        )
        self.fig = fig
        self.axs = axs
        for ax in ["A", "B", "C", "E", "F"]:
            axs[ax].spines["right"].set_visible(False)
            axs[ax].spines["top"].set_visible(False)
        fig.suptitle(
            f"{str(self.filename):s}  {protocol:s}", fontsize=8, fontweight="demibold"
        )
        if protocol.startswith("CCIV") or protocol.startswith("Ic"):
            delta_I = 0.075
        elif protocol.startswith("Vc") or protocol.startswith("Map"):
            delta_I = 100e-12
        else:
            raise ValueError(f"Protocol starting with : {protocol:s} not handled.")
        self.opto = False
        if protocol.startswith("Map"):
            self.opto = True

        for i in range(self.AR.traces.shape[0]):
            axs["A"].plot(
                self.timebase[:self.maxindex],
                self.idata[:self.maxindex,i] + i * delta_I,
                linewidth=0.33,
            )
            axs["B"].plot(
                self.timebase[:self.maxindex],
                self.command[:self.maxindex, i],
                linewidth=0.33,
            )

            if self.opto:
                axs["C"].plot(
                    self.AR.LaserBlue_time_base[:self.maxindex,i], self.AR.LaserBlue_pCell[:self.maxindex,i]
                )
        axs["F"].plot(
            self.timebase[:self.maxindex],
            np.mean(self.idata[:self.maxindex], axis=1),
            linewidth=0.5,
        )
        self.trace_plot = axs["E"].plot(
            self.timebase[:self.maxindex],
            self.idata[:self.maxindex, 0],
            "g-",
            linewidth=0.5,
        )
        self.ELabel = self.axs["E"].text(
            0.05,
            0.95,
            f"Trace: {0:d}",
            ha="left",
            va="top",
            transform=self.axs["E"].transAxes,
        )
        axs["A"].set_xlabel("T (s)")
        axs["F"].set_xlabel("T (s)")
        if recmode.lower() in ["cc", "ic"]:
            axs["A"].set_ylabel("V (V)")
            axs["B"].set_ylabel("I (A)")
            axs["F"].set_ylabel("V (V)")
        elif recmode.lower() in ["vc"]:
            axs["A"].set_ylabel("I (A)")
            axs["B"].set_ylabel("V (V)")
            axs["F"].set_ylabel("mean I (A)")
        if self.opto is not None:
            axs["C"].set_xlabel("T (s)")
            axs["C"].set_ylabel("Intensity (AU)")

        # draw a map of the points by current
        if self.opto is not None:
            osize = float(self.AR.scanner_spotsize)/1e3 # match units with positions
            patches = []
            # create a circle to show the position of each stimulus
            for isp in range(self.AR.scanner_positions.shape[0]):
                circle = mpatches.Circle(
                    (
                        self.AR.scanner_positions[isp, 0] / 1e3,
                        self.AR.scanner_positions[isp, 1] / 1e3,
                    ),
                    radius=osize / 2.0,
                    color="blue",
                    ec="none",
                )
                patches.append(circle)
            collection = PatchCollection(patches, cmap=mpl.cm.cool, alpha=0.6)
            istim = int(0.5 * self.AR.sample_rate[0])
            onems = int(0.001 * self.AR.sample_rate[0])
            twentyms = 20 * onems
            grandmean, grandstd = compute_scores.grand_mean_std(self.AR.time_base, 
                self.AR.traces, window=[0.480, 0.5])
            zscores = compute_scores.ZScore2D(self.AR.time_base,
                self.AR.traces, pre_std=grandstd, pre_mean=grandmean,
                twin_base = [0.480, 0.5], twin_resp = [0.501, 0.531])
            # zscore = np.sum(
            #     self.AR.traces[:, istim : istim + twentyms], axis=0
            # ) - np.mean(
            #     self.AR.traces[:, istim - twentyms : istim], axis=0
            # )  # , np.linspace(0, 1, len(patches))
            colors = zscores / np.max(zscores)  # scale to 1.0
            collection.set_array(colors)
            collection.set_picker(True)
            axs["D"].add_collection(collection)
            axs["D"].set_facecolor("white")
            axs["D"].set_aspect("equal")
            axs["D"].scatter(
                np.mean(self.AR.scanner_positions[:, 0]) / 1e3,
                np.mean(self.AR.scanner_positions[:, 1] / 1e3),
                s=0.1,
                marker="o",
            )
            fig.canvas.mpl_connect("pick_event", self.onpick)

        mpl.show()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Display an NWB file")
    parser.add_argument(dest="inputfile", type=str, help="input filenbame")
    args = parser.parse_args()

    R = ReadAcq4(args.inputfile)
    # R.plot_traces()
